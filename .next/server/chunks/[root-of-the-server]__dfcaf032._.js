module.exports = {

"[project]/.next-internal/server/app/apilocal/resultados/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/timers [external] (timers, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/app/database.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
;
const pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    port: parseInt(process.env.DB_PORT || '3306'),
    waitForConnections: true,
    connectionLimit: 10
});
console.log('DB_HOST:', process.env.DB_HOST);
console.log('DB_USER:', process.env.DB_USER);
console.log('DB_PASSWORD:', process.env.DB_PASSWORD);
console.log('DB_NAME:', process.env.DB_NAME);
const __TURBOPACK__default__export__ = pool;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[project]/src/app/apilocal/resultados/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// app/apilocal/resultados/route.ts
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/app/database.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/generative-ai/dist/index.mjs [app-route] (ecmascript)");
;
;
;
// Carga la clave API desde las variables de entorno
const API_KEY = process.env.GOOGLE_API_KEY;
// Inicializa el cliente de Gemini
const genAI = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenerativeAI"](API_KEY || '');
// Se configura el modelo con safetySettings AQUÍ, en getGenerativeModel
const model = genAI.getGenerativeModel({
    model: "gemini-1.5-flash",
    safetySettings: [
        {
            category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmCategory"].HARM_CATEGORY_HATE_SPEECH,
            threshold: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmBlockThreshold"].BLOCK_NONE
        },
        {
            category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmCategory"].HARM_CATEGORY_SEXUALLY_EXPLICIT,
            threshold: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmBlockThreshold"].BLOCK_NONE
        },
        {
            category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmCategory"].HARM_CATEGORY_HARASSMENT,
            threshold: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmBlockThreshold"].BLOCK_NONE
        },
        {
            category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmCategory"].HARM_CATEGORY_DANGEROUS_CONTENT,
            threshold: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HarmBlockThreshold"].BLOCK_NONE
        }
    ]
});
async function POST(request) {
    try {
        const body = await request.json();
        const { id_alumno, materia, respuestas_enviadas } = body; // 'respuestas_enviadas' ahora también incluye la pregunta original
        console.log('Datos de examen recibidos para calificar y guardar:', {
            id_alumno,
            materia,
            num_respuestas: respuestas_enviadas.length
        });
        if (!id_alumno || !materia || !Array.isArray(respuestas_enviadas)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Faltan datos obligatorios para calificar y guardar el examen'
            }, {
                status: 400
            });
        }
        const materiasPermitidas = [
            'bd',
            'web',
            'so'
        ];
        if (!materiasPermitidas.includes(materia)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Materia no válida para calificar'
            }, {
                status: 400
            });
        }
        let score = 0;
        const totalQuestions = respuestas_enviadas.length;
        const gradedResponses = [];
        // Mapeo de IDs de preguntas de opción múltiple a sus respuestas correctas
        // Esto es para las preguntas de DB y también si la IA genera preguntas con opciones marcadas
        const opcionQuestionIds = respuestas_enviadas.filter((r)=>r.tipo === 'opcion' && !String(r.id_pregunta).startsWith('1000')) // Filtra IDs que no son de IA si es necesario
        .map((r)=>r.id_pregunta);
        let correctOptionAnswersMap = new Map();
        if (opcionQuestionIds.length > 0) {
            // Consulta las respuestas correctas de las preguntas de opción múltiple DE LA BASE DE DATOS
            const [correctOptions] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].query('SELECT id_pregunta, opcion FROM respuestas_opciones WHERE id_pregunta IN (?) AND respuesta = 1', [
                opcionQuestionIds
            ]);
            correctOptions.forEach((opt)=>{
                correctOptionAnswersMap.set(opt.id_pregunta, opt.opcion);
            });
        }
        // --- Lógica de Calificación pregunta por pregunta ---
        for (const r of respuestas_enviadas){
            let isCorrect = false; // true, false, o null para revisión
            let feedback = '';
            let questionScore = 0; // Puntaje para esta pregunta (0 o 1)
            if (r.tipo === 'opcion') {
                // Para preguntas de opción múltiple (ya sea de DB o IA)
                // Las preguntas de IA YA TRAEN la información de 'esCorrecta' en sus 'opciones'
                const originalQuestion = r.pregunta_original; // Obtenemos la pregunta original enviada desde el frontend
                if (originalQuestion && originalQuestion.opciones && Array.isArray(originalQuestion.opciones)) {
                    // Buscamos la opción correcta entre las opciones de la pregunta original
                    const correctOption = originalQuestion.opciones.find((opt)=>opt.esCorrecta === 1);
                    if (correctOption && r.respuesta_usuario === correctOption.texto) {
                        isCorrect = true;
                        feedback = 'Correcta';
                        questionScore = 1;
                    } else {
                        isCorrect = false;
                        feedback = `Incorrecta. La respuesta correcta era: ${correctOption?.texto || 'N/A'}`;
                    }
                } else {
                    // Esto maneja preguntas de opción múltiple que NO vienen con opciones pre-calificadas (ej. las de la DB)
                    const correctOptionText = correctOptionAnswersMap.get(r.id_pregunta);
                    if (correctOptionText && r.respuesta_usuario === correctOptionText) {
                        isCorrect = true;
                        feedback = 'Correcta';
                        questionScore = 1;
                    } else {
                        isCorrect = false;
                        feedback = `Incorrecta. La respuesta correcta era: ${correctOptionText || 'N/A'}`;
                    }
                }
            } else if (r.tipo === 'abierta') {
                // --- Calificación de Preguntas Abiertas con IA ---
                const userResponse = r.respuesta_usuario;
                const originalQuestionText = r.pregunta_original.pregunta; // El texto de la pregunta abierta
                if (userResponse && userResponse.trim() !== '' && originalQuestionText) {
                    try {
                        const aiPrompt = `Califica la siguiente respuesta a una pregunta abierta en una escala del 0 al 1.0 (siendo 1.0 perfecto). No respondas con texto, solo con el número decimal.
            Pregunta: "${originalQuestionText}"
            Respuesta del alumno: "${userResponse}"
            Dame retroalimentación breve (1-2 frases) sobre por qué se le dio esa calificación.
            
            Formato de salida JSON:
            {
              "calificacion": 0.X,
              "feedback": "Tu respuesta es..."
            }`;
                        console.log('Enviando a IA para calificar pregunta abierta:', aiPrompt.substring(0, 100) + '...');
                        const aiResult = await model.generateContent(aiPrompt);
                        const aiResponse = await aiResult.response;
                        const aiText = aiResponse.text();
                        console.log('Respuesta de IA para calificación abierta:', aiText);
                        // Intentar parsear el JSON de la IA
                        const jsonMatch = aiText.match(/```json\n([\s\S]*?)\n```/);
                        let parsedAiResponse = null;
                        if (jsonMatch && jsonMatch[1]) {
                            parsedAiResponse = JSON.parse(jsonMatch[1]);
                        } else {
                            parsedAiResponse = JSON.parse(aiText); // Intenta parsear directamente
                        }
                        if (parsedAiResponse && typeof parsedAiResponse.calificacion === 'number' && typeof parsedAiResponse.feedback === 'string') {
                            questionScore = parsedAiResponse.calificacion; // La IA da la calificación directamente
                            feedback = parsedAiResponse.feedback;
                            isCorrect = questionScore > 0.5; // Si es mayor a 0.5, se considera "correcta" para fines de bandera
                        } else {
                            console.warn('La IA no devolvió el formato esperado para la calificación de pregunta abierta.');
                            isCorrect = null; // Necesita revisión manual
                            feedback = 'Calificación IA no disponible o formato incorrecto. Requiere revisión manual.';
                        }
                    } catch (aiGradingError) {
                        console.error('Error al calificar pregunta abierta con IA:', aiGradingError);
                        isCorrect = null; // Necesita revisión manual
                        feedback = 'Error en la calificación por IA. Requiere revisión manual.';
                    }
                } else {
                    isCorrect = false; // Si no hay respuesta del usuario, es incorrecta
                    feedback = 'Respuesta vacía.';
                }
            } else {
                isCorrect = null;
                feedback = 'Tipo de pregunta desconocido.';
            }
            // Suma el puntaje de la pregunta a la calificación total del examen
            score += questionScore;
            gradedResponses.push({
                id_pregunta: r.id_pregunta,
                tipo: r.tipo,
                pregunta_original: r.pregunta_original,
                respuesta_usuario: r.respuesta_usuario,
                esCorrecta: isCorrect,
                feedback: feedback,
                puntaje_pregunta: questionScore // Puntaje individual de la pregunta
            });
        }
        // Calcular la calificación final sobre 10
        // Asumimos que cada pregunta vale 1 punto para un total de 'totalQuestions' puntos.
        // Luego escalamos a una base de 10.
        const finalScoreOutOf10 = totalQuestions > 0 ? score / totalQuestions * 10 : 0;
        const finalScorePercentage = totalQuestions > 0 ? score / totalQuestions * 100 : 0;
        // --- Guardar el registro principal del examen ---
        const respuestasJsonString = JSON.stringify(gradedResponses);
        const [resultadoExamen] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].query('INSERT INTO resultados_examenes (id_alumno, materia, calificacion, respuestas_json, fecha_examen) VALUES (?, ?, ?, ?, NOW())', [
            id_alumno,
            materia,
            finalScoreOutOf10,
            respuestasJsonString
        ] // Guardamos la calificación sobre 10
        );
        const idResultadoExamen = resultadoExamen.insertId;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: 'Examen calificado y guardado exitosamente',
            idExamenGuardado: idResultadoExamen,
            calificacionFinal: finalScoreOutOf10.toFixed(2),
            calificacionPorcentaje: finalScorePercentage.toFixed(2),
            respuestasCalificadas: gradedResponses
        }, {
            status: 200
        });
    } catch (error) {
        console.error('Error al calificar y guardar los resultados del examen:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Error interno del servidor al calificar y guardar resultados',
            details: error.message
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__dfcaf032._.js.map