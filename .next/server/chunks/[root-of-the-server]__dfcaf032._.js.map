{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///home/luizpedro/Documentos/Web2/WebProyecto/src/app/database.ts"],"sourcesContent":["import mysql from 'mysql2/promise';\n\nconst pool = mysql.createPool({\n  host: process.env.DB_HOST,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME,\n  port: parseInt(process.env.DB_PORT || '3306'),\n  waitForConnections: true,\n  connectionLimit: 10\n});\n\nconsole.log('DB_HOST:', process.env.DB_HOST);\nconsole.log('DB_USER:', process.env.DB_USER);\nconsole.log('DB_PASSWORD:', process.env.DB_PASSWORD);\nconsole.log('DB_NAME:', process.env.DB_NAME);\n\n\nexport default pool;"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,OAAO,mIAAA,CAAA,UAAK,CAAC,UAAU,CAAC;IAC5B,MAAM,QAAQ,GAAG,CAAC,OAAO;IACzB,MAAM,QAAQ,GAAG,CAAC,OAAO;IACzB,UAAU,QAAQ,GAAG,CAAC,WAAW;IACjC,UAAU,QAAQ,GAAG,CAAC,OAAO;IAC7B,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI;IACtC,oBAAoB;IACpB,iBAAiB;AACnB;AAEA,QAAQ,GAAG,CAAC,YAAY,QAAQ,GAAG,CAAC,OAAO;AAC3C,QAAQ,GAAG,CAAC,YAAY,QAAQ,GAAG,CAAC,OAAO;AAC3C,QAAQ,GAAG,CAAC,gBAAgB,QAAQ,GAAG,CAAC,WAAW;AACnD,QAAQ,GAAG,CAAC,YAAY,QAAQ,GAAG,CAAC,OAAO;uCAG5B","debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///home/luizpedro/Documentos/Web2/WebProyecto/src/app/apilocal/resultados/route.ts"],"sourcesContent":["// app/apilocal/resultados/route.ts\nimport pool from '@/app/database';\nimport { NextResponse } from 'next/server';\nimport { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } from '@google/generative-ai';\n\n// Carga la clave API desde las variables de entorno\nconst API_KEY = process.env.GOOGLE_API_KEY;\n\n// Inicializa el cliente de Gemini\nconst genAI = new GoogleGenerativeAI(API_KEY || '');\n\n// Se configura el modelo con safetySettings AQUÍ, en getGenerativeModel\nconst model = genAI.getGenerativeModel({\n  model: \"gemini-1.5-flash\", // Usamos gemini-1.5-flash como el modelo actual recomendado\n  safetySettings: [\n    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },\n    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },\n    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },\n    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },\n  ],\n});\n\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { id_alumno, materia, respuestas_enviadas } = body; // 'respuestas_enviadas' ahora también incluye la pregunta original\n\n    console.log('Datos de examen recibidos para calificar y guardar:', {\n      id_alumno,\n      materia,\n      num_respuestas: respuestas_enviadas.length\n    });\n\n    if (!id_alumno || !materia || !Array.isArray(respuestas_enviadas)) {\n      return NextResponse.json({ error: 'Faltan datos obligatorios para calificar y guardar el examen' }, { status: 400 });\n    }\n\n    const materiasPermitidas = ['bd', 'web', 'so'];\n    if (!materiasPermitidas.includes(materia)) {\n      return NextResponse.json({ error: 'Materia no válida para calificar' }, { status: 400 });\n    }\n\n    let score = 0;\n    const totalQuestions = respuestas_enviadas.length;\n    const gradedResponses = [];\n\n    // Mapeo de IDs de preguntas de opción múltiple a sus respuestas correctas\n    // Esto es para las preguntas de DB y también si la IA genera preguntas con opciones marcadas\n    const opcionQuestionIds = respuestas_enviadas\n      .filter((r: any) => r.tipo === 'opcion' && !String(r.id_pregunta).startsWith('1000')) // Filtra IDs que no son de IA si es necesario\n      .map((r: any) => r.id_pregunta);\n\n    let correctOptionAnswersMap = new Map<number, string>();\n\n    if (opcionQuestionIds.length > 0) {\n      // Consulta las respuestas correctas de las preguntas de opción múltiple DE LA BASE DE DATOS\n      const [correctOptions]: any = await pool.query(\n        'SELECT id_pregunta, opcion FROM respuestas_opciones WHERE id_pregunta IN (?) AND respuesta = 1',\n        [opcionQuestionIds]\n      );\n      correctOptions.forEach((opt: any) => {\n        correctOptionAnswersMap.set(opt.id_pregunta, opt.opcion);\n      });\n    }\n\n    // --- Lógica de Calificación pregunta por pregunta ---\n    for (const r of respuestas_enviadas) {\n      let isCorrect: boolean | null = false; // true, false, o null para revisión\n      let feedback = '';\n      let questionScore = 0; // Puntaje para esta pregunta (0 o 1)\n\n      if (r.tipo === 'opcion') {\n        // Para preguntas de opción múltiple (ya sea de DB o IA)\n        // Las preguntas de IA YA TRAEN la información de 'esCorrecta' en sus 'opciones'\n        const originalQuestion = r.pregunta_original; // Obtenemos la pregunta original enviada desde el frontend\n\n        if (originalQuestion && originalQuestion.opciones && Array.isArray(originalQuestion.opciones)) {\n            // Buscamos la opción correcta entre las opciones de la pregunta original\n            const correctOption = originalQuestion.opciones.find((opt: any) => opt.esCorrecta === 1);\n\n            if (correctOption && r.respuesta_usuario === correctOption.texto) {\n                isCorrect = true;\n                feedback = 'Correcta';\n                questionScore = 1;\n            } else {\n                isCorrect = false;\n                feedback = `Incorrecta. La respuesta correcta era: ${correctOption?.texto || 'N/A'}`;\n            }\n        } else {\n            // Esto maneja preguntas de opción múltiple que NO vienen con opciones pre-calificadas (ej. las de la DB)\n            const correctOptionText = correctOptionAnswersMap.get(r.id_pregunta);\n            if (correctOptionText && r.respuesta_usuario === correctOptionText) {\n                isCorrect = true;\n                feedback = 'Correcta';\n                questionScore = 1;\n            } else {\n                isCorrect = false;\n                feedback = `Incorrecta. La respuesta correcta era: ${correctOptionText || 'N/A'}`;\n            }\n        }\n\n      } else if (r.tipo === 'abierta') {\n        // --- Calificación de Preguntas Abiertas con IA ---\n        const userResponse = r.respuesta_usuario as string;\n        const originalQuestionText = r.pregunta_original.pregunta; // El texto de la pregunta abierta\n\n        if (userResponse && userResponse.trim() !== '' && originalQuestionText) {\n          try {\n            const aiPrompt = `Califica la siguiente respuesta a una pregunta abierta en una escala del 0 al 1.0 (siendo 1.0 perfecto). No respondas con texto, solo con el número decimal.\n            Pregunta: \"${originalQuestionText}\"\n            Respuesta del alumno: \"${userResponse}\"\n            Dame retroalimentación breve (1-2 frases) sobre por qué se le dio esa calificación.\n            \n            Formato de salida JSON:\n            {\n              \"calificacion\": 0.X,\n              \"feedback\": \"Tu respuesta es...\"\n            }`;\n\n            console.log('Enviando a IA para calificar pregunta abierta:', aiPrompt.substring(0, 100) + '...');\n            const aiResult = await model.generateContent(aiPrompt);\n            const aiResponse = await aiResult.response;\n            const aiText = aiResponse.text();\n            console.log('Respuesta de IA para calificación abierta:', aiText);\n\n            // Intentar parsear el JSON de la IA\n            const jsonMatch = aiText.match(/```json\\n([\\s\\S]*?)\\n```/);\n            let parsedAiResponse: { calificacion: number; feedback: string } | null = null;\n            if (jsonMatch && jsonMatch[1]) {\n                parsedAiResponse = JSON.parse(jsonMatch[1]);\n            } else {\n                parsedAiResponse = JSON.parse(aiText); // Intenta parsear directamente\n            }\n\n            if (parsedAiResponse && typeof parsedAiResponse.calificacion === 'number' && typeof parsedAiResponse.feedback === 'string') {\n              questionScore = parsedAiResponse.calificacion; // La IA da la calificación directamente\n              feedback = parsedAiResponse.feedback;\n              isCorrect = questionScore > 0.5; // Si es mayor a 0.5, se considera \"correcta\" para fines de bandera\n            } else {\n              console.warn('La IA no devolvió el formato esperado para la calificación de pregunta abierta.');\n              isCorrect = null; // Necesita revisión manual\n              feedback = 'Calificación IA no disponible o formato incorrecto. Requiere revisión manual.';\n            }\n\n          } catch (aiGradingError: any) {\n            console.error('Error al calificar pregunta abierta con IA:', aiGradingError);\n            isCorrect = null; // Necesita revisión manual\n            feedback = 'Error en la calificación por IA. Requiere revisión manual.';\n          }\n        } else {\n          isCorrect = false; // Si no hay respuesta del usuario, es incorrecta\n          feedback = 'Respuesta vacía.';\n        }\n      } else {\n        isCorrect = null;\n        feedback = 'Tipo de pregunta desconocido.';\n      }\n\n      // Suma el puntaje de la pregunta a la calificación total del examen\n      score += questionScore;\n\n      gradedResponses.push({\n        id_pregunta: r.id_pregunta,\n        tipo: r.tipo,\n        pregunta_original: r.pregunta_original, // Incluimos la pregunta original para referencia\n        respuesta_usuario: r.respuesta_usuario,\n        esCorrecta: isCorrect,\n        feedback: feedback,\n        puntaje_pregunta: questionScore // Puntaje individual de la pregunta\n      });\n    }\n\n    // Calcular la calificación final sobre 10\n    // Asumimos que cada pregunta vale 1 punto para un total de 'totalQuestions' puntos.\n    // Luego escalamos a una base de 10.\n    const finalScoreOutOf10 = (totalQuestions > 0) ? (score / totalQuestions) * 10 : 0;\n    const finalScorePercentage = (totalQuestions > 0) ? (score / totalQuestions) * 100 : 0;\n\n\n    // --- Guardar el registro principal del examen ---\n    const respuestasJsonString = JSON.stringify(gradedResponses);\n\n    const [resultadoExamen]: any = await pool.query(\n      'INSERT INTO resultados_examenes (id_alumno, materia, calificacion, respuestas_json, fecha_examen) VALUES (?, ?, ?, ?, NOW())',\n      [id_alumno, materia, finalScoreOutOf10, respuestasJsonString] // Guardamos la calificación sobre 10\n    );\n\n    const idResultadoExamen = resultadoExamen.insertId;\n\n    return NextResponse.json(\n      {\n        message: 'Examen calificado y guardado exitosamente',\n        idExamenGuardado: idResultadoExamen,\n        calificacionFinal: finalScoreOutOf10.toFixed(2), // Calificación sobre 10\n        calificacionPorcentaje: finalScorePercentage.toFixed(2), // Calificación en porcentaje para info\n        respuestasCalificadas: gradedResponses\n      },\n      { status: 200 }\n    );\n  } catch (error: any) {\n    console.error('Error al calificar y guardar los resultados del examen:', error);\n    return NextResponse.json(\n      { error: 'Error interno del servidor al calificar y guardar resultados', details: error.message },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}